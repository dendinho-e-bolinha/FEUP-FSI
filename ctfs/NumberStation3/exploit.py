# Python Module ciphersuite
import os
import sys
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from binascii import hexlify, unhexlify

FLAG_FILE = 'flag.txt'

# Use crypto random generation to get a key with length n
def gen(): 
    rkey = bytearray(os.urandom(16))
    for i in range(16): rkey[i] = rkey[i] & 1
    return bytes(rkey)

# Bitwise XOR operation.
def enc(k, m):
	cipher = Cipher(algorithms.AES(k), modes.ECB())
	encryptor = cipher.encryptor()
	cph = b""
	for ch in m:
		cph += encryptor.update((ch*16).encode())
	cph += encryptor.finalize()
	return cph

# Reverse operation
def dec(k, c):
	assert len(c) % 16 == 0
	cipher = Cipher(algorithms.AES(k), modes.ECB())
	decryptor = cipher.decryptor()
	blocks = len(c)//16
	msg = b""
	for i in range(0,(blocks)):
		msg+=decryptor.update(c[i*16:(i+1)*16])
		msg=msg[:-15]
	msg += decryptor.finalize()
	return msg


enc_flag = "f5fc80417d833c7381ca7302b82e1e882b1c0ef93901b1f746fe7e0ce614d9c3a090207d2f422b2a3a733b2b65d3ad98668425dc95e1e6c50aa528563468337519d1eb92983ad872d63a3b791ed139d6091ee32ca29237e99458739f6e0c1f091b94d8cecee60715b3106096f14a2152a73f99c7360f16ff91c99f70480b5f3839c239791a4d57b50c3551f936ae57b1a73f99c7360f16ff91c99f70480b5f38a088baf5f6fde621c9e7978822c95f87a088baf5f6fde621c9e7978822c95f871b6c28fcccf60cec5cfa7da2eefc2136a090207d2f422b2a3a733b2b65d3ad981b94d8cecee60715b3106096f14a21521841b8865347bc2e015047560473fb4459311df02aa242b65b95e9792b1486efa090207d2f422b2a3a733b2b65d3ad981ae86296b3a19bfc3124db14adad7bdda090207d2f422b2a3a733b2b65d3ad981b6c28fcccf60cec5cfa7da2eefc2136a088baf5f6fde621c9e7978822c95f87091ee32ca29237e99458739f6e0c1f091b94d8cecee60715b3106096f14a2152091ee32ca29237e99458739f6e0c1f091841b8865347bc2e015047560473fb441841b8865347bc2e015047560473fb44883efe337a4d2fe5be7aeff6e74796e7a088baf5f6fde621c9e7978822c95f8759311df02aa242b65b95e9792b1486ef0a240ca7c89acde11a6b3347b51c096da088baf5f6fde621c9e7978822c95f871841b8865347bc2e015047560473fb44a73f99c7360f16ff91c99f70480b5f380a240ca7c89acde11a6b3347b51c096da090207d2f422b2a3a733b2b65d3ad98091ee32ca29237e99458739f6e0c1f0954b97d20eb7284b1fd44d10c8bf167f9d3e06b65587bde9feaca1cf7b16d0826"

masks = [2**i for i in range(0, 16)]
for possible_key in range(0, 2**16):
    key = [0] * 16
    for i in range(0, 16):
        if possible_key & masks[i]:
            key[i] = 1
    key = bytes(key)
    try:
        flag_bytes = b'flag'
        dec_bytes = dec(key, unhexlify(enc_flag))
        if flag_bytes in dec_bytes:
            print(dec_bytes.decode())
    except:
        pass


sys.stdout.flush()